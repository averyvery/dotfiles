" @group vundle

filetype off

set rtp+=~/.vim/bundle/vundle/
set rtp+=~/.vim/
set rtp+=~/.vim/snippets
call vundle#rc()

" let Vundle manage Vundle
" required!
Bundle 'gmarik/vundle'

" My Bundles here
" original repos on github

" some basics
Bundle 'vim-scripts/L9'
Bundle 'vim-scripts/genutils'
Bundle 'tpope/vim-surround'

" file management
Bundle 'tpope/vim-fugitive'
Bundle 'scrooloose/nerdtree'
Bundle 'shemerey/vim-peepopen'

" apps
Bundle 'vim-scripts/vimwiki'
Bundle 'averyvery/vim-scratch'

" languages
Bundle 'averyvery/sparkup', {'rtp': 'vim/'}
Bundle 'skammer/vim-css-color'
Bundle 'sickill/vim-pasta'
Bundle 'tpope/vim-commentary'
Bundle 'scrooloose/syntastic'

" tools
Bundle 'sjl/gundo.vim'
Bundle 'SirVer/ultisnips'
Bundle 'Lokaltog/vim-powerline'

" searching
Bundle 'mileszs/ack.vim'
Bundle 'averyvery/vim-browsereload-mac'

" keep vim indent guides LAST. It messes stuff up
Bundle 'nathanaelkane/vim-indent-guides'

" Brief help
" :BundleList        - list configured bundles
" :BundleInstall(!)    - install(update) bundles
" :BundleSearch(!) foo - search(or refresh cache first) for foo
" :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles

runtime macros/matchit.vim

" @end

" @group weird settings

set nrformats=
set nocompatible
set modelines=0
set encoding=utf-8
set history=5000
" set wildmode=longest:full
" set wildmenu
set ttyfast
set virtualedit=onemore
set invmmta
set noeb vb t_vb=
au GUIEnter * set vb t_vb=
set scrolloff=5
set nocompatible
set lazyredraw
set wrap
set showbreak=--->\  " prefix for soft-wrapped lines (no actual line break character)
set clipboard=unnamed
set langmenu=none
set backspace=indent,eol,start
set guioptions=Acer
set ruler         " Display info on current position
set laststatus=2  " Always show status line

filetype plugin on

" http://stackoverflow.com/questions/3478755/macvim-open-file-in-existing-window
autocmd BufWinEnter,BufNewFile * silent tab

" http://www.reddit.com/r/vim/comments/t1lhc/cursorcolumn_cursorline_slowdown/
autocmd CursorHold * setlocal cursorline cursorcolumn
autocmd CursorMoved,InsertEnter *
  \ if &l:cursorline | setlocal nocursorline nocursorcolumn | endif

set undofile
set undodir=~/.vim/tmp/undo//
set backupdir=~/.vim/tmp/backup//
set directory=~/.vim/tmp/swap//

autocmd BufWinEnter,BufNewFile * let g:UltiSnipsSnippetDirectories=['snippets']

" @end

" @group numbers

set relativenumber
set numberwidth=1
autocmd BufLeave * setlocal nonumber norelativenumber
autocmd BufEnter * setlocal number relativenumber

" @end

" @group timing

set timeout
set ttimeout
set timeoutlen=500
set ttimeoutlen=150

autocmd InsertEnter * setlocal timeoutlen=150
autocmd InsertLeave * setlocal timeoutlen=500

" @end

" @group leader

let mapleader="\\"

nmap <leader>u :GundoToggle<CR>
nmap <leader>w :w !sudo tee %<Enter>
nmap <leader>g :vimgrep // **/*.*<left><left><left><left><left><left><left><left>
nmap <leader>a :Ack --type=
nmap <leader>s :SyntasticCheck<CR>
nmap <leader><esc> :bufdo bdelete<CR>:echo 'Buffers cleared'<CR>

nmap <silent> <leader>b :BufExplorer<CR>
nmap <leader>c :topleft cwindow<CR>

function! Load()
  echo 'Session loaded'
  source ~/.vim_session
endfunction

nmap <leader>o :call Load()<CR>

" @end

" @group session

set sessionoptions=blank,buffers,curdir,folds,help,resize,tabpages,winsize

function! Clear()
  echo 'Session cleared'
  :silent !rm ~/.vim_session
endfunction

" @end

" @group visuals

set guifont=Ubuntu\ Mono:h14

let g:Powerline_symbols = 'fancy'
let g:Powerline_stl_path_style = 'relative'

colorscheme handcrafted

call Pl#Theme#RemoveSegment('mode_indicator')
call Pl#Theme#RemoveSegment('scrollpercent')
call Pl#Theme#RemoveSegment('fileformat')
call Pl#Theme#RemoveSegment('fileencoding')
call Pl#Theme#RemoveSegment('filetype')

" @end

" @group reference

nmap <leader>s :Scratch<CR>
nmap <backspace> :e ~/dotfiles/vim/wiki/index.wiki<CR>

" @end

" @group indents and tabs

" Tabs

set expandtab
set shiftwidth=2
set tabstop=2
set smartindent

" Invisibles
set listchars=tab:\>-,trail:~,extends:↳,precedes:↵

autocmd BufWinEnter,BufNewFile * set list

autocmd BufNewFile,BufRead *.css setlocal filetype=css noexpandtab
autocmd BufNewFile,BufRead *.css.php setlocal filetype=css noexpandtab
autocmd BufNewFile,BufRead *.less setlocal filetype=css noexpandtab
autocmd BufNewFile,BufRead *.scss setlocal filetype=css noexpandtab
autocmd BufNewFile,BufRead *.js setlocal noexpandtab
autocmd BufNewFile,BufRead *.json setlocal noexpandtab
autocmd BufNewFile,BufRead *.css.sass set filetype=rb
autocmd BufNewFile,BufRead *.mobile.erb setlocal filetype=html noexpandtab shiftwidth=1 tabstop=1
autocmd BufNewFile,BufRead *.html.php setlocal filetype=html noexpandtab shiftwidth=1 tabstop=1
autocmd BufNewFile,BufRead *.html.erb setlocal filetype=html noexpandtab shiftwidth=1 tabstop=1
autocmd BufNewFile,BufRead *.erb setlocal filetype=html noexpandtab shiftwidth=1 tabstop=1
autocmd BufNewFile,BufRead *.html setlocal filetype=html noexpandtab shiftwidth=1 tabstop=1
autocmd BufEnter * if &filetype == "" | setlocal expandtab shiftwidth=2 | endif
autocmd BufNewFile,BufRead *.rb setlocal expandtab tabstop=2 shiftwidth=2
autocmd BufNewFile,BufRead *.c setlocal expandtab tabstop=4 shiftwidth=4

" @end

" @group expansion and completion

let g:sparkupExecuteMapping = '<c-a>'
let g:UltiSnipsExpandTrigger = '<tab>'
let g:UltiSnipsJumpForwardTrigger = '<tab>'
let g:UltiSnipsJumpBackwardTrigger = '<s-tab>'
let g:UltiSnipsListSnippets = '<m-tab>'

" Completion
inoremap <S-esc> <C-p>

" @end

" @group file management and searches

nnoremap / /\v
vnoremap / /\v
set ignorecase
set smartcase
set gdefault
set incsearch
set showmatch
set hlsearch

" map <silent> <esc> :w<CR>:mksession! ~/.vim_session<CR>:silent! %s/\s\+$//<CR>:w<CR>
" not really working
function! Reload()
  echo &filetype
  if &filetype == 'javascript' || &filetype == 'html' || &filetype == 'css'
    echo "Reloading Chrome"
    call :ChromeReload()
  endif
endfunction

let g:returnApp = "Google Chrome Canary"

nmap <silent> <esc> :silent! w<CR>:silent! %s/\s\+$//<CR>:w<CR>
nmap <silent> <s-esc> :silent! w<CR>:silent! %s/\s\+$//<CR>:silent! w<CR>:ChromeReload<CR>

let g:NERDTreeWinPos='right'
let NERDTreeMapOpenInTab='\t'
nmap <silent> <leader>p :PeepOpen<CR>
nmap <silent> <leader>t :NERDTree<CR>
"
" @end

" @group dvorak

" movement
no d h
no h j
no <s-h> 10j
no t k
no <s-t> 10k
no n l
no S 0wc$

" deletion
no j d

" search
no l n
no L N

" 'til
no k t
no <s-k> <s-t>

" only used for autocomplete
inoremap <c-t> <up>
inoremap <c-h> <down>

" bonus
no <space> a<space><esc>
no <s-space> i<space><esc>l

" @end

" @group indenting and folding

set foldmethod=marker
set foldmarker=@group,@end
set fillchars=stl:\ ,stlnc:\ ,vert:\|,fold:\ ,diff:-
" set foldclose=all

let g:indent_guides_auto_colors = 0
autocmd BufWinEnter,BufNewFile * :IndentGuidesEnable

" Folds
nmap <M-h> zj
nmap <M-t> zk
nmap <M-d> zc
nmap <M-n> zo

" Adapted from http://vim.wikia.com/wiki/Back_and_forth_between_indented_lines_again
function! MoveIndent(forward, out, in)
  let line = line('.')
  let column = col('.')
  let lastline = line('$')
  let indent = indent(line)
  let stepvalue = a:forward ? 1 : -1
  while (line > 0 && line <= lastline)
    let line = line + stepvalue
    if (a:out && indent(line) < indent || a:in && indent(line) > indent || indent(line) == indent && !a:out && !a:in)
      if (strlen(getline(line)) > 0)
        exe line
        exe "normal " column . "|"
        return
      endif
    endif
  endwhile
endfunction

function! IndentEnd()
  call MoveIndent(1, 0, 0)
endfunction

function! IndentStart()
  call MoveIndent(0, 0, 0)
endfunction

function! IndentOuter()
  call MoveIndent(0, 1, 0)
endfunction

function! IndentInner()
  call MoveIndent(1, 0, 1)
endfunction

function! BindIndentAction(key)
  exe ":nnoremap " . a:key . "<C-h> :normal ^mm<CR> :call IndentEnd()<CR> :normal " . a:key . "'m<CR>"
  exe ":nnoremap " . a:key . "<C-t> :normal ^mm<CR> :call IndentStart()<CR> :normal " . a:key . "'m<CR>"
  exe ":nnoremap " . a:key . "<C-d> :call IndentOuter()<CR> :normal ^mm<CR> :call IndentEnd()<CR> :normal " . a:key . "'m<CR>"
  exe ":nnoremap " . a:key . "<C-n> :normal ^hmmt<CR> :call IndentEnd()<CR> :normal t<CR> :normal " . a:key . "'m<CR>"
endfunction

nnoremap g> :call IndentEnd()<CR>
nnoremap g< :call IndentStart()<CR>
" nnoremap <C-d> :call IndentOuter()<CR>
" nnoremap <C-n> :call IndentInner()<CR>

" nmap ]] :call IndentEnd()<CR>
" nmap [[ :call IndentStart()<CR>
" nmap [] :call IndentOuter()<CR>
" nmap ][ :call IndentInner()<CR>

" @end

" @group better indents

" http://vim.wikia.com/wiki/Indent_text_object
" Changes to allow blank lines in blocks, and
" Top level blocks (zero indent) separated by two or more blank lines.
" Usage: source <thisfile> in pythonmode and
" Press: vai, vii to select outer/inner python blocks by indetation.
" Press: vii, yii, dii, cii to select/yank/delete/change an indented block.
onoremap ai :<C-u>call IndTxtObj(0,0)<CR>
onoremap ii :<C-u>call IndTxtObj(1,0)<CR>
vnoremap ai <Esc>:call IndTxtObj(0,0)<CR><Esc>gv
vnoremap ii <Esc>:call IndTxtObj(1,0)<CR><Esc>gv
" nnoremap gai :<C-u>call IndTxtObj(0,0)<CR>vv
" nnoremap gii :<C-u>call IndTxtObj(1,0)<CR>vv
" nnoremap gAi :<C-u>call IndTxtObj(0,1)<CR>vv
" nnoremap gIi :<C-u>call IndTxtObj(1,1)<CR>vv

function! IndTxtObj(inner,reverse)
  let curcol = col(".")
  let curline = line(".")
  let lastline = line("$")
  let i = indent(line("."))
  if getline(".") !~ "^\\s*$"
    let p = line(".") - 1
    let pp = line(".") - 2
    let nextblank = getline(p) =~ "^\\s*$"
    let nextnextblank = getline(pp) =~ "^\\s*$"
    while p > 0 && ((i == 0 && (!nextblank || (pp > 0 && !nextnextblank))) || (i > 0 && ((indent(p) >= i && !(nextblank && a:inner)) || (nextblank && !a:inner))))
      -
      let p = line(".") - 1
      let pp = line(".") - 2
      let nextblank = getline(p) =~ "^\\s*$"
      let nextnextblank = getline(pp) =~ "^\\s*$"
    endwhile
    normal! 0V
    call cursor(curline, curcol)
    let p = line(".") + 1
    let pp = line(".") + 2
    let nextblank = getline(p) =~ "^\\s*$"
    let nextnextblank = getline(pp) =~ "^\\s*$"
    while p <= lastline && ((i == 0 && (!nextblank || pp < lastline && !nextnextblank)) || (i > 0 && ((indent(p) >= i && !(nextblank && a:inner)) || (nextblank && !a:inner))))
      +
      let p = line(".") + 1
      let pp = line(".") + 2
      let nextblank = getline(p) =~ "^\\s*$"
      let nextnextblank = getline(pp) =~ "^\\s*$"
    endwhile
    normal! $
  endif
  if(a:inner == 0)
    echo('not inner')
    normal hoto
  endif
  if(a:reverse)
    normal o_
  endif
endfunction

" @end

" @group bubbling

" no <c-m-t> :m-2<cr>
" no <c-m-h> :m+<cr>
" no <c-m-n> <<
" no <c-m-s> >>

" @end

" @group syntastic & jshint

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_enable_signs=1
let g:syntastic_auto_loc_list=1
let g:syntastic_quiet_warnings = 1

" http://stackoverflow.com/questions/4579300/vimgrep-and-the-quickfix-window-in-macvim
let g:syntastic_auto_loc_list=1

let g:syntastic_mode_map = {
  \ 'mode': 'active',
  \ 'active_filetypes': ['php'],
  \ 'passive_filetypes': ['html', 'js']
  \ }

" @end

" @group sections
"
map [[ ?{<CR>w99[{
map ][ /}<CR>b99]}
map ]] h0[[%/{<CR>
map [] t$][%?}<CR>

" @end

" @group grep

function! Grep()
  let file = input('filetype: ')
  execute 'normal :vimgrep // **/*.' . file . '<left><left><left><left><left><left><left><left>'
endfunction

" nmap <leader>g :call Grep()<CR>

" @end

" @group fugitive

nnoremap <silent> <leader>=s :Gstatus<CR>
nnoremap <silent> <leader>=d :Gdiff<CR>
nnoremap <silent> <leader>=c :Gcommit<CR>
nnoremap <silent> <leader>=b :Gblame<CR>
nnoremap <silent> <leader>=l :Glog<CR>
nnoremap <silent> <leader>=p :Git push<CR>

" @end

" @group disable stuff

" map <LeftMouse> <Nop>
" map <RightMouse> <Nop>

" @end

" @group arrows

nmap <right> >>
nmap <left> <<
nmap <up> jjtP
nmap <down> jjp

" @end

" @group tags

autocmd BufWritePost *.js call system("ctags -R")

" @end
