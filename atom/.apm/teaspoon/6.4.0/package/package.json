{"name":"teaspoon","version":"6.4.0","description":"jQuery-esque Api for React elements and instances, supports complex css selectors","main":"index.js","repository":{"type":"git","url":"git+https://github.com/jquense/teaspoon.git"},"keywords":["react","test","query"],"author":{"name":"jquense"},"license":"MIT","bugs":{"url":"https://github.com/jquense/teaspoon/issues"},"homepage":"https://github.com/jquense/teaspoon","peerDependencies":{"react":"^0.14.0-rc1 || ^15.0.0","react-dom":"^0.14.0-rc1 || ^15.0.0"},"dependencies":{"bill":"^3.2.1","dom-helpers":"^2.4.0","invariant":"^2.2.0","lodash":"^3.10.1","promise":"^7.1.1","react-addons-test-utils":"^0.14.0-rc1 || ^15.0","warning":"^2.1.0"},"readme":"\nteaspoon\n========\n\nJust the right amount of abstraction for writing clear, and concise React component tests.\n\n__migrating? Check out the [update guide](Migration.md)__\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [Getting Started](#getting-started)\n  - [Using selectors](#using-selectors)\n  - [Complex selectors](#complex-selectors)\n- [Testing patterns](#testing-patterns)\n  - [Using `tap()`](#using-tap)\n  - [Test specific querying (\"ref\" style querying).](#test-specific-querying-ref-style-querying)\n- [Adding collection methods and pseudo selectors](#adding-collection-methods-and-pseudo-selectors)\n  - [createPseudo(pseudo: string, handler: (innerValue: string) => (node: Node) => bool)](#createpseudopseudo-string-handler-innervalue-string--node-node--bool)\n- [API](#api)\n  - [Rendering](#rendering)\n      - [`$.fn.render([Bool renderIntoDocument, HTMLElement mountPoint, Object context ])`](#fnrenderbool-renderintodocument-htmlelement-mountpoint-object-context-)\n      - [`$.fn.shallowRender([props]) -> ElementCollection`](#fnshallowrenderprops---elementcollection)\n      - [`$.element.fn.update()`](#elementfnupdate)\n      - [`$.instance.fn.unmount()`](#instancefnunmount)\n  - [Utility methods and properties](#utility-methods-and-properties)\n      - [`$.selector` => selector _(alias: $.s)_](#selector--selector-_alias-s_)\n      - [`$.dom(instance) => HTMLElement`](#dominstance--htmlelement)\n      - [`$.compileSelector(selector) => (node) => bool`](#compileselectorselector--node--bool)\n      - [`$.defaultContext(context: ?object) => (node) => bool`](#defaultcontextcontext-object--node--bool)\n      - [`$.fn.length`](#fnlength)\n      - [`$.fn.unwrap() => Element|Instance|HTMLElement`](#fnunwrap--elementinstancehtmlelement)\n      - [`$.fn.get() => Array` (alias: toArray())](#fnget--array-alias-toarray)\n      - [`$.fn.tap() => function(Collection)`](#fntap--functioncollection)\n      - [`$.fn.end() => Collection`](#fnend--collection)\n      - [`$.fn.each(Function iteratorFn)`](#fneachfunction-iteratorfn)\n      - [`$.fn.map(Function iteratorFn)`](#fnmapfunction-iteratorfn)\n      - [`$.fn.reduce(Function iteratorFn, [initialValue]) -> Collection`](#fnreducefunction-iteratorfn-initialvalue---collection)\n      - [`$.fn.reduceRight(Function iteratorFn) -> Collection`](#fnreducerightfunction-iteratorfn---collection)\n      - [`$.fn.some(Function iteratorFn) -> bool`](#fnsomefunction-iteratorfn---bool)\n      - [`$.fn.every(Function iteratorFn) -> bool`](#fneveryfunction-iteratorfn---bool)\n      - [`$.instance.fn.dom -> HTMLElement`](#instancefndom---htmlelement)\n  - [Accessors](#accessors)\n      - [`$.fn.props`](#fnprops)\n      - [`$.fn.state`](#fnstate)\n      - [`$.fn.context`](#fncontext)\n  - [Traversal methods](#traversal-methods)\n      - [`$.fn.find(selector)`](#fnfindselector)\n      - [`$.fn.filter(selector)`](#fnfilterselector)\n      - [`$.fn.is(selector) -> Bool`](#fnisselector---bool)\n      - [`$.fn.children([selector])`](#fnchildrenselector)\n      - [`$.fn.parent([selector])`](#fnparentselector)\n      - [`$.fn.parents([selector])`](#fnparentsselector)\n      - [`$.fn.closest([selector])`](#fnclosestselector)\n      - [`$.fn.first([selector])`](#fnfirstselector)\n      - [`$.fn.last([selector])`](#fnlastselector)\n      - [`$.fn.only()`](#fnonly)\n      - [`$.fn.single(selector)`](#fnsingleselector)\n      - [`$.fn.any([selector])`](#fnanyselector)\n      - [`$.fn.none([selector])`](#fnnoneselector)\n      - [`$.fn.text()`](#fntext)\n  - [Events](#events)\n      - [`$.instance.fn.trigger(String eventName, [Object data])`](#instancefntriggerstring-eventname-object-data)\n      - [`$.element.fn.trigger(String eventName, [Object data])`](#elementfntriggerstring-eventname-object-data)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Getting Started\n\nTo get started install teaspoon via npm:\n\n```sh\nnpm i --save-dev teaspoon\n```\n\nTeaspoon is test environment agnostic, so you can (and should) bring your own test runner and frameworks.\nIf you plan on doing normal component rendering (not just shallow rendering) you will also need a DOM environment,\nwhether that's a browser, headless browser, or jsdom.\n\nLike jQuery teaspoon exports a function that creates a collection of nodes; except in this case\nyou select React elements instead of DOM nodes.\n\n```js\nimport $ from 'teaspoon';\n\nlet $div = $(<div />);\n\n$div.length // 1\n$div[0]     // ReactElement{ type: 'div', props: {} ... }\n```\n\nSince there is no globally accessible \"document\" of React elements like there is of DOM nodes, you need\nto start by selecting a tree. Once you have a tree you can query it with css selectors and jQuery-like methods.\n\n```js\nlet elements = (\n  <MyComponent>\n    <MyInput/>\n    <MyInput/>\n    <div className='fun-div'>  \n  </MyComponent>\n);\n\nlet $elements = $(elements);\n\n$elements.find('div.fun-div').length // 1\n$elements.find(MyInput).length // 2\n```\n\nAlong with plain ol' ReactElements you can also use teaspoon to traverse a rendered component tree.\nTeaspoon also does a bunch of work under the hood to normalize the traversal behavior of DOM components,\nCustom Components, and Stateless function Components.\n\n```js\nlet Greeting = props => <div>hello <strong>{props.name}</strong></div>;\n\nlet instance = ReactDOM.render(<Greeting name='John' />, mountNode)\n\nlet $instance = $(instance);\n\n$instance.find('strong').text() // \"John\"\n```\n\nThat's nice but a bit verbose, luckily teaspoon lets you switch between both collection types\n(element and instance) nice and succinctly.\n\n```js\nlet Greeting = props => <div>hello <strong>{props.name}</strong></div>;\n\n// renders `<Greeting/>` into the DOM and returns an collection of instances\nlet $elements = $(<Greeting />).render();\n\n$elements.find('strong').text() // \"John\"\n\n$elements.unmount() // removes the mounted component and returns a collection of elements\n\n//or with shallow rendering\n$elements.shallowRender()\n  .find('strong').text() // \"John\"\n```\n\n### Using selectors\n\nThe supported selector syntax is subset of standard css selectors:\n\n- classes: `.foo`\n- attributes: `div[propName=\"hi\"]` or `div[boolProp]`\n- `>`: direct descendant `div > .foo`\n- `+`: adjacent sibling selector\n- `~`: general sibling selector\n- `:has()`: parent selector `div:has(a.foo)`\n- `:not()`: negation\n- `:first-child`\n- `:last-child`\n- `:text` matches \"text\" (renderable) nodes, which may be a non string value (like a number)\n- `:dom` matches only DOM components\n- `:composite` matches composite (user defined) components\n- `:contains(some text)` matches nodes that have a text node descendant containing the provided text\n- `:textContent(some text)` matches whose text content matches the provided text\n\nSelector support is derived from the underlying selector engine: [bill](https://github.com/jquense/bill). New minor\nversions of bill are released independent of teaspoon, so you can always check there to see what is supported on the\ncutting edge.\n\n### Complex selectors\n\nUnlike normal css selectors, React elements and components often have prop values, and component types that are\nnot serializable to a string; components are often best selected by their actual class and not a name, and\nprop values can complex objects such as a `date` prop equaling `new Date()`.\n\nFor components, we've already seen that you can use the function name or the `displayName`, but\nsometimes they aren't available. A less brittle approach is to select by the function _itself_. You can\nuse a [tagged template string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings).\nvia the `$.selector` (also aliased as `$.s`) function for writing complex selectors like so:\n\n```js\n$.s`div > ${Greeting}`\n\n// select components with `start` props _strictly_ equal to `min`\nlet min = 10\n$.s`[start=${min}]`\n```\n\nIf you don't want to use the newer syntax you can also call the `selector` function directly like:\n\n```js\n$.s('div > ', Greeting, '.foo') // equivalent to: $.s`div > ${Greeting}.foo`\n```\n\nUse can use these complex selectors in any place a selector is allowed:\n\n```js\nlet Name = props => <strong>{props.name}</strong>;\nlet Time = props => <em>{props.date.toLocaleString()}</em>\nlet Greeting = props => <div>hello <Name {...props} /> its: <Time {...props} /></div>;\n\nlet now = new Date();\nlet $inst = $(<Greeting name='John' date={now} />);\n\n$inst\n  .render()\n  .find($.s`${Greeting} > strong`)\n  .text()\n\n$inst\n  .shallowRender()\n  .find($.s`${Time}[date=${now}]`)\n  .only()  \n```\n\n## Testing patterns\n\nAs far as testing libraries go `teaspoon` has fairly few opinions about how to do stuff, so you can adapt whatever\ntesting practices and patterns you like. However there are some patterns and paths that fall out naturally from\nteaspoon's API.\n\n### Using `tap()`\n\n[`tap()`](#fntap---functioncollection) provides a way to quickly step in the middle of a chain of queries and\ncollections to make a quick assertion. Below we quickly make a few changes to the component props and\ncheck that the rendered output is what we'd expect.\n\n```js\nlet Greeting = props => <div>hello <strong>{props.name}</strong></div>;\n\n$(<Greeting name='rikki-tikki-tavi'/>)\n  .render()\n  .tap(collection => {\n    collection\n      .first('div > :text')\n      .unwrap()\n      .should.equal('hello rikki-tikki-tavi')\n  })\n  .props('name', 'Nagaina')\n  .tap(collection => {\n    collection\n      .first('div > :text')\n      .unwrap()\n      .should.equal('hello Nagaina')\n  })\n  .unmount()\n```\n\n### Test specific querying (\"ref\" style querying).\n\nAn age old struggle with testing HTML output is that tests are usually not very resilient to\nDOM structure changes. You may move a save button into (or out of) some div that your test used to find the button,\nbreaking the test. A classic technique to avoid this is the just use css classes, however it can be hard to\ndistinguish between styling classes, and testing hooks.\n\nIn a React environment we can do one better, adding test specific attribute. This is a pattern taken up by libraries like\n[react-test-tree](https://github.com/QubitProducts/react-test-tree), and while `teaspoon` doesn't specifically \"support\"\nthat style of selection, its selector engine is more than powerful enough to allow that pattern of querying.\n\nYou can choose any prop name you like, but we recommend picking one that isn't likely to collide with a\ncomponent's \"real\" props. In this example let's use `_testID`.\n\n```js\nlet Greeting = props => <div>hello <strong _testID='name'>{props.name}</strong></div>;\n\n$(<Greeting name='Betty' />)\n  .render()\n  .find('[_testID=name]')\n  .text()\n  .should.equal('Betty')\n```\n\nYou can adapt and expand this pattern however your team likes, maybe just using the single testing prop or a few.\nYou can also add some helper methods or pseudo selectors to help codify enforce your teams testing conventions.\n\n## Adding collection methods and pseudo selectors\n\nTeaspoon also allows extending itself and adding new pseudo selectors using a fairly straight forward API.\n\nTo add a new method for all collection types add it to `$.fn`\n(or `$.prototype` if the jQuery convention bothers you).\n\n```js\n// Returns all DOM node descendants and filters by a selector\n$.fn.domNodes = function(selector) {\n  return this\n    .find(':dom')\n    .filter(selector)\n}\n\n// also works with shallowRender()\n$(<MyComponent />).render().domNodes('.foo')\n```\n\nIf you want to make a method only available to either instance of element collections you can extend\n`$.instance.fn` or `$.element.fn` following the same pattern as above.\n\n### createPseudo(pseudo: string, handler: (innerValue: string) => (node: Node) => bool)\n\nFor new pseudo selectors you can use the `createPseudo` API which provides\na hook into the css selector engine used by teaspoon: [bill](https://github.com/jquense/bill). Pseudo selectors _do_\nintroduce a new object not extensively covered here, the `Node`. A Node is a light abstraction that\nencapsulates both component instances and React elements, in order to provide a common traversal API across tree types.\nYou can read about them and their properties [here](https://github.com/jquense/bill#node).\n\n```js\n// input:name(email)\n$.createPseudo('name', function (name) {\n  // return a function that matches against elements or instances\n  return function (node) {\n    return $(node).is(`[name=${name}]`)\n  }\n})\n\n// We want to test if an element has a sibling that matches\n// a selector e.g. :nextSibling(.foo)\n$.createPseudo('nextSibling', function (selector) {\n  // turning the selector into a matching function up front\n  // is a bit more performant, alternatively we could just do $(node).is(selector);\n  let matcher = $.compileSelector(selector)\n\n  return function (node) {\n    let sibling = node.nextSibling;\n    return sibling != null && matcher(sibling)\n  }\n})\n```\n\n## API\n\nTeaspoon does what it can to abstract away the differences between element and instance collections into a\ncommon API, however everything doesn't coalesce nicely, so some methods are only relevant and available for\ncollections of instances and some for collections of elements.\n\nMethods that are common to both collections are listed as: `$.fn.methodName`\n\nWhereas methods that are specific to a collection type are\nlisted as: `$.instance.fn.methodName` and `$.element.fn.methodName` respectively\n\n### Rendering\n\n##### `$.fn.render([Bool renderIntoDocument, HTMLElement mountPoint, Object context ])`\n\nRenders the first element of the Collection into the DOM using `ReactDom.render`. By default\nthe component won't be added to the page `document`, you can pass `true` as the first parameter to render into the\ndocument.body. Additionally you can provide your own DOM node to mount the component into and/or a `context` object.\n\n`render()` returns a new _InstanceCollection_\n\n```js\nlet elements = (\n  <MyComponent>\n    <div className='fun-div'>  \n  </MyComponent>\n);\n\nlet $elements = $(elements).render();\n\n// accessible by document.querySelectorAll\n$elements = $(elements).render(true);\n\n// mount the component to the <span/>\n$elements = $(elements).render(document.createElement('span'));\n```\n\n##### `$.fn.shallowRender([props]) -> ElementCollection`\n\nUse the React shallow renderer utilities to _shallowly_ render the first element of the collection.\n\n```js\nlet MyComponent ()=> <div>Hi there!</div>\n\n$(<MyComponent/>)\n  .find('div')\n  .length // 0\n\n$(<MyComponent/>)\n  .shallowRender()\n  .find('div')\n  .length // 1\n```\n\n##### `$.element.fn.update()`\n\nSince shallow collections are not \"live\" in the same way a real rendered component tree is, you may\nneed to manually update the root collection to flush changes (such as those triggered by a child component).\n\nIn general you may not have to ever use `update()` since teaspoon tries to take care of all that for\nyou by spying on the `componentDidUpdate` life-cycle hook of root component instance.\n\n##### `$.instance.fn.unmount()`\n\nUnmount the current tree and remove it from the DOM. `unmount()` returns an\nElementCollection of the _root_ component element.\n\n```js\nlet $inst = $(<Greeting name='John' date={now} />);\nlet rendered = $inst.render();\n\n//do some stuff...then:\nrendered.unmount()\n```\n\n### Utility methods and properties\n\nThe methods are shared by both Element and Instance Collections.\n\n##### `$.selector` => selector _(alias: $.s)_\n\nSelector creation function.\n\n##### `$.dom(instance) => HTMLElement`\n\nReturns the DOM nodes for a component instance, if it exists.\n\n##### `$.compileSelector(selector) => (node) => bool`\n\nCompiles a selector into a function that matches a node\n\n##### `$.defaultContext(context: ?object) => (node) => bool`\n\nYou can globally set a context object to be used for each and all renders,\nshallow or otherwise. This is helpful for context that is available to all\nlevels of the application, like the `router`, i18n context, or a Redux Store.\n\n##### `$.fn.length`\n\nThe length of the collection.\n\n##### `$.fn.unwrap() => Element|Instance|HTMLElement`\n\nUnwraps a collection of a single item returning the item. Equivalent to `$el[0]`; throws when there\nis more than one item in the collection.\n\n```js\n$(<div><strong>hi!</strong></div>)\n  .find('strong')\n  .unwrap() // -> <strong>hi!</strong>\n```\n\n##### `$.fn.get() => Array` (alias: toArray())\n\nReturns a real JavaScript array of the collection items.\n\n##### `$.fn.tap() => function(Collection)`\n\nRun an arbitrary function against the collection, helpful for making assertions while chaining.\n\n```js\n$(<MyComponent/>).render()\n  .prop({ name: 'John '})\n  .tap(collection =>\n    expect(collection.children().length).to.equal(2))\n  .find('.foo')\n```\n\n##### `$.fn.end() => Collection`\n\nExits a chain, by returning the previous collection\n\n```js\n$(<MyComponent/>).render()\n  .find('ul')\n    .single()\n  .end()\n  .find('div')\n```\n\n##### `$.fn.each(Function iteratorFn)`\n\nAn analog to `Array.prototype.forEach`; iterates over the collection calling the `iteratorFn`\nwith each item, index, and collection.\n\n```js\n$(<MyComponent/>).render()\n  .find('div')\n  .each((node, index, collection)=>{\n    //do something\n  })\n```\n\n##### `$.fn.map(Function iteratorFn)`\n\nAn analog to `Array.prototype..map`; maps over the collection calling the `iteratorFn`\nwith each item, index, and collection.\n\n```js\n$(<MyComponent/>).render()\n  .find('div')\n  .map((node, index, collection) => {\n    //do something\n  })\n```\n\n##### `$.fn.reduce(Function iteratorFn, [initialValue]) -> Collection`\n\nAn analog to `Array.prototype..reduce`, returns a new _reduced_ teaspoon Collection\n\n```js\n$(<MyComponent/>).render()\n  .find('div')\n  .reduce((current, node, index, collection)=>{\n    return current + ', ' + node.textContent\n  }, '')\n```\n\n##### `$.fn.reduceRight(Function iteratorFn) -> Collection`\n\nAn analog to `Array.prototype.reduceRight`.\n\n##### `$.fn.some(Function iteratorFn) -> bool`\n\nAn analog to `Array.prototype.some`.\n\n##### `$.fn.every(Function iteratorFn) -> bool`\n\nAn analog to `Array.prototype.every`.\n\n##### `$.instance.fn.dom -> HTMLElement`\n\nReturns the DOM nodes for each item in the Collection, if the exist\n\n### Accessors\n\n##### `$.fn.props`\n\nSet or get props from a component or element.\n\nSetting props can only be done on __root__ collections given the\nreactive nature of data flow in react trees (or on any element of a tree that isn't rendered).\n\n- `.props()`: retrieve all props\n- `.props(propName)`: retrieve a single prop\n- `.props(propName, propValue, [callback])`: update a single prop value\n- `.props(newProps, [callback])`: merge `newProps` into the current set of props.\n\n##### `$.fn.state`\n\nSet or get state from a component or element. In shallowly rendered trees only the __root__ component\ncan be stateful.\n\n- `.state()`: retrieve state\n- `.state(stateName)`: retrieve a single state value\n- `.state(stateName, stateValue, [callback])`: update a single state value\n- `.state(newState, [callback])`: merge `newState` into the current state.\n\n##### `$.fn.context`\n\nSet or get state from a component or element. In shallowly rendered trees only the __root__ component\ncan have context.\n\n- `.context()`: retrieve context\n- `.context(String contextName)`: retrieve a single context value\n- `.context(String contextName, Any contextValue, [Function callback])`: update a single context value\n- `.context(Object newContext, [Function callback])`: replace current context.\n\n### Traversal methods\n\n##### `$.fn.find(selector)`\n\nSearch all descendants of the current collection, matching against\nthe provided selector.\n\n```js\n$(\n<div>\n  <ul>\n    <li>item 1</li>\n  </ul>\n</div>\n).find('ul > li')\n```\n\n##### `$.fn.filter(selector)`\n\nFilter the current collection matching against the provided\nselector.\n\n```js\nlet $list = $([\n  <li>1</li>,\n  <li className='foo'>2</li>,\n  <li>3</li>,\n]);\n\n$list.filter('.foo').length // 1\n```\n\n##### `$.fn.is(selector) -> Bool`\n\nTest if each item in the collection matches the provided\nselector.\n\n##### `$.fn.children([selector])`\n\nReturn the children of the current selection, optionally filtered by those matching a provided selector.\n\n__note:__ rendered \"Composite\" components will only ever have one child since Components can only return a single node.\n\n```js\nlet $list = $(\n  <ul>\n    <li>1</li>\n    <li className='foo'>2</li>\n    <li>3</li>\n  </ul>\n);\n\n$list.children().length // 3\n\n$list.children('.foo').length // 1\n```\n\n##### `$.fn.parent([selector])`\n\nGet the parent of each node in the current collection, optionally filtered by a selector.\n\n##### `$.fn.parents([selector])`\n\nGet the ancestors of each node in the current collection, optionally filtered by a selector.\n\n##### `$.fn.closest([selector])`\n\nFor each node in the set, get the first element that matches the selector by testing the element\nand traversing up through its ancestors.\n\n##### `$.fn.first([selector])`\n\nreturn the first item in a collection, alternatively search all\ncollection descendants matching the provided selector and return\nthe first match.\n\n##### `$.fn.last([selector])`\n\nreturn the last item in a collection, alternatively search all\ncollection descendants matching the provided selector and return\nthe last match.\n\n##### `$.fn.only()`\n\nAssert that the current collection as only one item.\n\n```js\nlet $list = $(\n  <ul>\n    <li>1</li>\n    <li className='foo'>2</li>\n    <li>3</li>\n  </ul>\n);\n\n$list.find('li').only() // Error! Matched more than one <li/>\n\n$list.find('li.foo').only().length // 1\n```\n\n##### `$.fn.single(selector)`\n\nFind assert that only item matches the provided selector.\n\n```js\nlet $list = $(\n  <ul>\n    <li>1</li>\n    <li className='foo'>2</li>\n    <li>3</li>\n  </ul>\n);\n\n$list.single('li') // Error! Matched more than one <li/>\n\n$list.single('.foo').length // 1\n```\n\n\n##### `$.fn.any([selector])`\n\nAssert that the collection contains one or more nodes.\nOptionally search by a provided selector.\n\n```js\nlet $list = $(\n  <ul>\n    <li>1</li>\n    <li className='foo'>2</li>\n    <li>3</li>\n  </ul>\n);\n\n$list.any('p')  // Error!\n\n$list.any('li').length // 3\n```\n\n##### `$.fn.none([selector])`\n\nAssert that the collection contains no nodes. Optionally search by a provided selector.\n\n```js\nlet $list = $(\n  <ul>\n    <li>1</li>\n    <li className='foo'>2</li>\n    <li>3</li>\n  </ul>\n);\n\n$list.none('li')  // Error!\n\n$list.none('p').length // 0\n```\n\n##### `$.fn.text()`\n\nReturn the text content of the matched Collection.\n\n```js\nlet $els = $(<div>Hello <strong>John</strong></div)\n\n$els.text() // \"Hello John\"\n```\n\n\n### Events\n\nUtilities for triggering and testing events on rendered and shallowly rendered components.\n\n##### `$.instance.fn.trigger(String eventName, [Object data])`\n\nTrigger a \"synthetic\" React event on the collection items. works just like `ReactTestUtils.simulate`\n\n```js\n  $(<Component/>).render()\n    .trigger('click', { target: { value: 'hello ' } }).\n```\n\n##### `$.element.fn.trigger(String eventName, [Object data])`\n\nSimulates (poorly) event triggering for shallow collections. The method looks for a prop\nfollowing the convention 'on[EventName]': `trigger('click')` calls `props.onClick()`, and re-renders the root collection\n\nEvents don't bubble and don't have a proper event object.\n\n```js\n  $(<Component/>).shallowRender()\n    .find('button')\n    .trigger('click', { target: { value: 'hello ' } }).\n```\n","readmeFilename":"README.md","_id":"teaspoon@6.4.0","_shasum":"34d31950e0fd616e8a2fdea5d6140e1aa4479fcb","_resolved":"https://registry.npmjs.org/teaspoon/-/teaspoon-6.4.0.tgz","_from":"https://registry.npmjs.org/teaspoon/-/teaspoon-6.4.0.tgz"}