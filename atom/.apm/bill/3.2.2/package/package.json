{"name":"bill","version":"3.2.2","description":"css selectors for React Elements","main":"index.js","repository":{"type":"git","url":"git+https://github.com/jquense/bill.git"},"keywords":["react","test","query","css","selector","react-component","tree","traversal","react element","node"],"author":{"name":"jquense"},"license":"MIT","bugs":{"url":"https://github.com/jquense/bill/issues"},"homepage":"https://github.com/jquense/bill","peerDependencies":{"react":"^0.13.0 || ^0.14.0 || ^15.0.0"},"dependencies":{"css-selector-parser":"^1.1.0","escape-regexp":"0.0.1","fn-name":"^2.0.1","lodash":"^3.10.1","semver":"^5.1.0"},"readme":"bill\r\n=======\r\n\r\nSort of like [Sizzle](https://github.com/jquery/sizzle/tree/master#sizzle) for React, `bill` is\r\na set of tools for matching React Element and Component trees against CSS selectors. `bill` is meant to be a\r\nsubstrate library for building more interesting and user friendly testing utilities. It probably shouldn't\r\nbe used as a standalone tool.\r\n\r\n```js\r\nimport { querySelectorAll } from 'bill';\r\n\r\nlet matches = querySelectorAll('div li.foo',\r\n  <div>\r\n    <List>\r\n      <li className='foo'>John</li>\r\n      <li>Betty</li>\r\n    </List>\r\n  </div>\r\n)\r\n\r\nmatches.length     // 1\r\nmatches[0].element // ReactElement{ type: 'li', props: { className: 'foo' } }\r\n```\r\n\r\nFor selecting non string values, like custom Component types, you can use a [tagged template strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings)\r\n\r\n```js\r\nimport { querySelectorAll, selector as s } from 'bill';\r\n\r\nlet min = 5;\r\n\r\nlet matches = querySelectorAll(s`div > ${List}, li[min=${min}]`,\r\n  <div>\r\n    <List>\r\n      <li min={min}>John</li>\r\n      <li>Betty</li>\r\n    </List>\r\n  </div>\r\n)\r\n\r\nmatches.length     // 2\r\nmatches[0].element // { type: List, props }\r\n```\r\n\r\n### Supported\r\n\r\n- id: `#foo`\r\n- classes: `.foo`\r\n- attributes: `div[propName=\"hi\"]` or `div[boolProp]`\r\n- `>`: direct descendent `div > .foo`\r\n- `+`: adjacent sibling selector\r\n- `~`: general sibling selector\r\n- `:has()`: parent selector `div:has(a.foo)`\r\n- `:not()`: negation\r\n- `:first-child`\r\n- `:last-child`\r\n- `:text` matches \"text\" (renderable) nodes, which may be a non string value (like a number)\r\n- `:dom` matches only DOM components\r\n- `:composite` matches composite (user defined) components\r\n\r\n### Not supported\r\n\r\n- other pseudo selectors\r\n- non string interpolations for anything other than \"tag\" or prop values\r\n\r\n## API\r\n\r\n#### Node\r\n\r\nNodes are a light object abstraction over both instances and elements that allow for a common\r\nmatching and traversal API between the distinct types of React objects.\r\nThe interface is similar to a traditional DOM node.\r\n\r\nMost `bill` methods that accept elements or instances will also accept a node,\r\nallowing you to use the return values of the methods directly with other methods.\r\n\r\n```js\r\nNode : {\r\n  nodeType: NODE_TYPE,\r\n  element: ReactElement,\r\n  instance: ReactComponent | HTMLElement,\r\n  privateInstance: ReactPrivateInstance,\r\n  nextSibling: Node,\r\n  prevSibling: Node,\r\n  parentNode: Node,\r\n  children: Array<Node>,\r\n  findAll: (test (node) => bool, includeSelf? : bool) => array<Node>\r\n}\r\n```\r\n\r\nTheir is a caveat to the `publicInstance` property, when it comes to stateless functional components. Instead\r\nof returning `null` as React would, `bill` returns the instance of the internal wrapper component. This is to allow,\r\npotential chaining and also retrieval of the underlying DOM node if necessary (as in the example above).\r\n\r\n__Note:__ Nodes only have instances when matching against a _rendered_ component tree\r\n\r\n#### `querySelectorAll(selector, subject: Element|Instance|Node) -> Array<Node>`\r\n\r\n`querySelectorAll()` traverses a react element or instance tree searching for nodes that match the provided selector.\r\nAs the name suggests it's analogous to `document.querySelectorAll`. The return value\r\nis an __array of Nodes__.\r\n\r\n```js\r\nlet matches;\r\nlet elements = (\r\n  <div>\r\n    <List>\r\n      <li className='foo'>John</li>\r\n      <li>Betty</li>\r\n    </List>\r\n  </div>\r\n)\r\n\r\n// find elements in the above element description\r\nmatches = bill.querySelectorAll('div li.foo', elements)\r\n\r\n// \"John\"\r\nlet textContent = matches.reduce(\r\n  (str, node) => str + node.element.props.children, '')\r\n\r\n// or search a rendered hierarchy\r\nmatches = bill.querySelectorAll('div li.foo', ReactDOM.render(elements))\r\n\r\nlet domNodes = matches.map(\r\n  node => ReactDOM.findDOMNode(node.instance))\r\n```\r\n\r\n#### `matches(selector, subject: Element|Instance|Node) -> bool`\r\n\r\nAnalogous to the DOM `element.matches` method, `matches` returns true if a give element, instance or node is matched\r\nby the provided `selector`.\r\n\r\n```js\r\nlet matches;\r\nlet elements = (\r\n  <div>\r\n    <List>\r\n      <li className='foo'>John</li>\r\n      <li>Betty</li>\r\n    </List>\r\n  </div>\r\n)\r\n\r\nlet johnItem = bill\r\n  .querySelectorAll('div li', elements)\r\n  .filter(node => bill.matches('.foo', node))\r\n\r\n\r\n// or search a rendered hierarchy\r\nlet bettyItem = bill\r\n  .querySelectorAll('div li.foo', ReactDOM.render(elements))\r\n  .filter(node => bill.matches(':not(.foo)', node))\r\n```\r\n\r\n#### `selector() -> Selector`\r\n\r\nA function used for tagged template strings,\r\n\r\nYou really only need to use the `selector` function when you want to write a selector matching exact prop values or a\r\ncomposite type.\r\n\r\n```js\r\nselector`div > ${List}[length=${5}]`\r\n```\r\n\r\n#### findAll(subject: Element|Instance|Node, test: (node: Node)=> bool, includeSelf? : bool) -> Array<Node>\r\n\r\nA tree traversal utility function for finding nodes that return `true` from the `testFunction`. findAll\r\nis similar to `ReactTestUtils.findAllInRenderedTree`, but more robust and works on both elements and instance trees.\r\n\r\n```js\r\nimport { findAll, NODE_TYPES } from 'bill';\r\n\r\nlet found = findAll(elements, function (node) {\r\n  return node.nodeType === NODE_TYPES.COMPOSITE\r\n})\r\n```\r\n\r\n#### compile(selector) => (node: Node) => bool\r\n\r\nCompiles a selector string into a function that matches nodes.\r\n\r\n#### registerPseudo(pseudoSelector, handlePseudo: (selector) => (node: Node) => bool)\r\n\r\nRegisters a new pseudo selector with the compiler. The second parameter is a function that will be called\r\nwith the pseudo selector's argument (if it exists). The handler function should return a function that matches\r\na node.\r\n\r\n```js\r\n// A simple `:text(foo)` pseudo selector\r\nbill.registerPseudo('text', function(value) {\r\n  return function (node) {\r\n    return node.children\r\n      .filter(n => n.nodeType === NODE_TYPES.TEXT)\r\n      .every(node => node.element === value)\r\n  }\r\n})\r\n\r\nlet matches = bill.querySelectorAll('li:text(john)',\r\n  <ul>\r\n    <li>betsy</li>\r\n    <li>john</li>\r\n    <li>yolanda</li>\r\n  </ul>\r\n)\r\n\r\nmatches[0].instance // <li class='bar'>john</li>\r\n```\r\n\r\nFor pseudoSelectors whose inner argument is a selector, you can compile it\r\nto a test function with `bill.compile`.\r\n\r\n```js\r\n// We want to test if an element has a sibling that matches\r\n// a selector e.g. :nextSibling(.foo)\r\nbill.registerPseudo('nextSibling', function (selector) {\r\n  let matcher = bill.compile(selector);\r\n  return function (node) {\r\n    node = node.nextSibling\r\n    return !!node && matcher(node)\r\n  }\r\n})\r\n\r\nlet matches = bill.querySelectorAll('li:nextSibling(li.baz)',\r\n  <ul>\r\n    <li className='foo'>1</li>\r\n    <li className='bar'>2</li>\r\n    <li className='baz'>3</li>\r\n  </ul>\r\n)\r\n\r\nmatches[0].instance // <li class='bar'>2</li>\r\n```\r\n\r\n#### registerNesting(nestingCombinator, handleNesting: (matcher: function) => (node: Node) => bool)\r\n\r\nSimilar to `registerPseudo` you can also register new combinator selectors (\\*, >, ~, +) using the same pattern.\r\nThe handler function is called with the _compiled_ selector segment.\r\n\r\n__Note:__ remember that selectors are matched _right-to-left_ so the logic is generally reversed from what you\r\nmight expect.\r\n\r\n```js\r\n// lets implement the same previous sibling selector as above\r\n// but with a nesting selector.\r\nbill.registerNesting('!', test => node => {\r\n  node = node.nextSibling\r\n  return !!(node && test(node))\r\n})\r\n\r\nlet matches = bill.querySelectorAll('li.baz ! li',\r\n  <ul>\r\n    <li className='foo'>1</li>\r\n    <li className='bar'>2</li>\r\n    <li className='baz'>3</li>\r\n  </ul>\r\n)\r\n\r\nmatches[0].instance // <li class='bar'>2</li>\r\n```\r\n\r\n\r\n#### `NODE_TYPES` Object\r\n\r\nSet of constants that correspond to `Node.nodeType`. Useful for filtering out types of nodes while traversing a tree.\r\n\r\n- `NODE_TYPES.COMPOSITE`\r\n- `NODE_TYPES.DOM`\r\n- `NODE_TYPES.TEXT`\r\n\r\n#### `isNode() -> boolean`\r\n\r\nDetermine if an object is a Node object.\r\n","readmeFilename":"README.md","_id":"bill@3.2.2","_shasum":"b7cde7ea03a874f9c90096286c037a2c4c60ac9e","_resolved":"https://registry.npmjs.org/bill/-/bill-3.2.2.tgz","_from":"https://registry.npmjs.org/bill/-/bill-3.2.2.tgz"}