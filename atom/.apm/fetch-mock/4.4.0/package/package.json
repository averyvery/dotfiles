{"name":"fetch-mock","version":"4.4.0","description":"Mock http requests made using fetch (or isomorphic-fetch)","main":"src/server.js","browser":"es5/client.js","scripts":{"test":"make test","browserify":"browserify -s fetchMock src/client.js > es5/client-browserified.js","prepublish":"babel src --out-dir es5 --presets es2015 && npm run browserify"},"repository":{"type":"git","url":"git+https://github.com/wheresrhys/fetch-mock.git"},"keywords":["fetch","http","mock","testing","spy"],"author":{"name":"Rhys Evans"},"license":"ISC","bugs":{"url":"https://github.com/wheresrhys/fetch-mock/issues"},"homepage":"https://github.com/wheresrhys/fetch-mock","dependencies":{"node-fetch":"^1.3.3"},"devDependencies":{"babel":"^6.0.15","babel-cli":"^6.1.2","babel-preset-es2015":"^6.1.2","babelify":"^7.2.0","browserify":"^12.0.0","chai":"^2.3.0","eslint":"^1.10.3","karma":"^0.12.31","karma-browserify":"^4.1.2","karma-chai":"^0.1.0","karma-chrome-launcher":"^0.1.8","karma-firefox-launcher":"^0.1.6","karma-mocha":"^0.1.10","karma-phantomjs-launcher":"^0.2.1","mocha":"^2.2.4","mockery":"^1.4.0","sinon":"^1.17.0","whatwg-fetch":"^0.10.1"},"browserify":{"transform":[["babelify",{"presets":["es2015"]}]]},"readme":"# fetch-mock [![Build Status](https://travis-ci.org/wheresrhys/fetch-mock.svg?branch=master)](https://travis-ci.org/wheresrhys/fetch-mock)\nMock http requests made using fetch (or [isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch)). As well as shorthand methods for the simplest use cases, it offers a flexible API for customising all aspects of \tmocking behaviour.\n\n## Installation and usage\n\n`npm install fetch-mock` then `require('fetch-mock')` in most environments.\n\n[Troubleshooting and alternative installation](#troubleshooting), [V4 changelog](#v4-changelog)\n\n## Basic usage\n\n**`require('fetch-mock')` exports a singleton with the following methods**\n\n#### `mock(matcher, response)` or `mock(matcher, method, response)`\nReplaces `fetch()` with a stub which records its calls, grouped by route, and optionally returns a mocked `Response` object or passes the call through to `fetch()`. Calls to `.mock()` can be chained.\n\n* `matcher` [required]: Condition for selecting which requests to mock Accepts any of the following\n\t* `string`: Either an exact url to match e.g. 'http://www.site.com/page.html' or, if the string begins with a `^`, the string following the `^` must begin the url e.g. '^http://www.site.com' would match 'http://www.site.com' or 'http://www.site.com/page.html'\n\t* `RegExp`: A regular  expression to test the url against\n\t* `Function(url, opts)`: A function (returning a Boolean) that is passed the url and opts `fetch()` is called with (or, if `fetch()` was called with one, the `Request` instance)\n* `method` [optional]: only matches requests using this http method\n* `response` [required]: Configures the http response returned by the mock. Can take any of the following values (or be a `Promise` for any of them, enabling full control when testing race conditions etc.)\n\t* `number`: Creates a response with this status\n\t* `string`: Creates a 200 response with the string as the response body\n\t* `object`: As long as the object does not contain any of the properties below it is converted into a json string and returned as the body of a 200 response. If any of the properties below are defined it is used to configure a `Response` object\n\t\t* `body`: Set the response body (`string` or `object`)\n\t\t* `status`: Set the response status (defaut `200`)\n\t\t* `headers`: Set the response headers. (`object`)\n\t\t* `throws`: If this property is present then a `Promise` rejected with the value of `throws` is returned\n\t\t* `sendAsJson`: This property determines whether or not the request body should be JSON.stringified before being sent (defaults to true).\n\t* `Function(url, opts)`: A function that is passed the url and opts `fetch()` is called with and that returns any of the responses listed above  \n\n#### `restore()`\nRestores `fetch()` to its unstubbed state and clears all data recorded for its calls\n\n#### `reMock()`\nCalls `restore()` internally then calls `mock()`. This allows you to put some generic calls to `mock()` in a `beforeEach()` while retaining the flexibility to vary the responses for some tests. `reMock()` can be chained.\n\n#### `reset()`\nClears all data recorded for `fetch()`'s calls\n\n*Note that `restore()`, `reMock()` and `reset()` are all bound to fetchMock, and can be used directly as callbacks e.g. `afterEach(fetchMock.restore)` will work just fine. There is no need for `afterEach(function () {fetchMock.restore()})`*\n\n**For the methods below `matcher`, if given, should be either the name of a route (see advanced usage below) or equal to `matcher.toString()` for any unnamed route**\n\n#### `calls(matcher)`\nReturns an object `{matched: [], unmatched: []}` containing arrays of all calls to fetch, grouped by whether fetch-mock matched them or not. If `matcher` is specified then only calls to fetch matching that route are returned.\n\n#### `called(matcher)`\nReturns a Boolean indicating whether fetch was called and a route was matched. If `matcher` is specified it only returns `true` if that particular route was matched.\n\n#### `lastCall(matcher)`\nReturns the arguments for the last matched call to fetch\n\n#### `lastUrl(matcher)`\nReturns the url for the last matched call to fetch\n\n#### `lastOptions(matcher)`\nReturns the options for the last matched call to fetch\n\n##### Example\n\n```js\nfetchMock\n\t.mock('http://domain1', 200)\n\t.mock('http://domain2', 'PUT', {\n\t\taffectedRecords: 1\n\t});\n\nmyModule.onlyCallDomain2()\n\t.then(() => {\n\t\texpect(fetchMock.called('http://domain2')).to.be.true;\n\t\texpect(fetchMock.called('http://domain1')).to.be.false;\n\t\texpect(fetchMock.calls().unmatched.length).to.equal(0);\n\t\texpect(JSON.parse(fetchMock.lastUrl('http://domain2'))).to.equal('http://domain2/endpoint');\n\t\texpect(JSON.parse(fetchMock.lastOptions('http://domain2').body)).to.deep.equal({prop: 'val'});\n\t})\n\t.then(fetchMock.restore)\n```\n\n## Advanced usage\n\n#### `mock(routeConfig)`\n\nUse a configuration object to define a route to mock.\n* `name` [optional]: A unique string naming the route. Used to subsequently retrieve references to the calls, grouped by name. If not specified defaults to `matcher.toString()` *Note: If a non-unique name is provided no error will be thrown (because names are optional, so auto-generated ones may legitimately clash)*\n* `method` [optional]: http method\n* `matcher` [required]: as specified above\n* `response` [required]: as specified above\n\n#### `mock(routes)`\nPass in an array of route configuration objects\n\n#### `mock(config)`\n\nPass in an object containing more complex config for fine grained control over every aspect of mocking behaviour. May have the following properties\n* `routes`: Either a single route config object or an array of them (see above).\n* `greed`: Determines how the mock handles unmatched requests\n\t* 'none': all unmatched calls get passed through to `fetch()`\n\t* 'bad': all unmatched calls result in a rejected promise\n\t* 'good': all unmatched calls result in a resolved promise with a 200 status\n\n#### *deprecated* `useNonGlobalFetch(func)`\nWhen using isomorphic-fetch or node-fetch ideally `fetch` should be added as a global. If not possible to do so you can still use fetch-mock in combination with [mockery](https://github.com/mfncooper/mockery) or similar in nodejs. To use fetch-mock with with [mockery](https://github.com/mfncooper/mockery) you may use this function to prevent fetch-mock trying to mock the function globally.\n* `func` Optional reference to `fetch` (or any other function you may want to substitute for `fetch` in your tests). This will probably have zero effect on your tests unless you are deliberately using the `greed: 'none'` config option to let some requests pass through to the original `fetch` implementation\n\n## Troubleshooting and alternative installation\n\n### `fetch` is assigned to a local variable, not a global\n\nFirst of all, consider whether you could just use `fetch` as a global. Here are 3 reasons why this is a good idea:\n- The `fetch` standard defines it as a global (and in some cases it won't work unless bound to `window`), so to write isomorphic code it's probably best to stick to this pattern\n- [`isomorphic-fetch`](https://www.npmjs.com/package/isomorphic-fetch) takes care of installing it as a global in nodejs or the browser, so there's no effort on your part to do so.\n- `fetch-mock` is primarily designed to work with `fetch` as a global and your experience of using it will be far more straightforward if you follow this pattern\n\nStill not convinced?\n\nIn that case `fetchMock.fetchMock` (or *[deprecated]* call `getMock()`) gives you access to the mock implementation of `fetch` which you can pass in to a mock loading library such as [`mockery`](https://www.npmjs.com/package/mockery)\n\n##### Mockery example\n```js\nvar fetch = require('node-fetch');\nvar fetchMock = require('fetch-mock');\nvar mockery = require('mockery');\n\nit('should make a request', function (done) {\n\tmockery.registerMock('node-fetch', fetchMock.fetchMock);\n\tfetchMock.mock('http://domain.com/', 200)\n\tconst myModule = require('./src/my-mod'); // this module requires node-fetch and assigns to a variable\n\t// test code goes in here\n\tmockery.deregisterMock('fetch');\n\tdone();\n});\n```\n### `fetch` doesn't seem to be getting mocked?\nIf using a mock loading library such as `mockery`, are you requiring the module you're testing after registering `fetch-mock` with the mock loader? You probably should be ([Example incorrect usage](https://github.com/wheresrhys/fetch-mock/issues/70)). If you're using ES6 `import` it may not be possible to do this without reverting to using `require()` sometimes. I *did* warn you about not using `fetch` as a global (...sigh)\n\n### Environment doesn't support requiring fetch-mock?\n* If your client-side code or tests do not use a loader that respects the browser field of package.json use `require('fetch-mock/es5/client')`.\n* If you need to use fetch-mock without commonjs, you can include the precompiled `node_modules/fetch-mock/es5/client-browserified.js` in a script tag. This loads fetch-mock into the `fetchMock` global variable.\n* For server side tests running in nodejs 0.12 or lower use `require('fetch-mock/es5/server')`\n\n### Polyfilling fetch\n* In nodejs `require('isomorphic-fetch')` before any of your tests.\n* In the browser `require('isomorphic-fetch')` can also be used, but it may be easier to `npm install whatwg-fetch` (the module isomorphic-fetch is built around) and load `./node_modules/whatwg-fetch/fetch.js` directly into the page, either in a script tag or by referencing it your test runner config\n\n## V4 changelog\n* `registerRoute()` and `unregisterRoute()` have been removed to simplify the API. Since V3, calls to `.mock()` can be chained, so persisting routes over a series of tests can easily be achieved by means of a beforeEach or helper e.g.\n\n```js\nbeforeEach(() => {\n\tfetchMock\n\t\t.mock('http://auth.service.com/user', 200)\n\t\t.mock('http://mvt.service.com/session', {test1: true, test2: false})\n});\n\nafterEach(() => {\n\tfetchMock.restore();\n});\n\nit('should be possible to augment persistent set of routes', () => {\n\tfetchMock.mock('http://content.service.com/contentid', {content: 'blah blah'})\n\tpage.init();\n\texpect(fetchMock.called('http://content.service.com/contentid')).to.be.true;\n});\n```\n* Defining two routes with the same name will no longer throw an error (previous implementation was buggy anyway)\n* Added `lastCall()`, `lastUrl()` and `lastOptions()` utilities\n","readmeFilename":"README.md","_id":"fetch-mock@4.4.0","_shasum":"e954daf1ade48c8fa0b6e2078dd10018f7a2f35a","_resolved":"https://registry.npmjs.org/fetch-mock/-/fetch-mock-4.4.0.tgz","_from":"https://registry.npmjs.org/fetch-mock/-/fetch-mock-4.4.0.tgz"}