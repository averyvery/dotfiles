{"name":"jsx-control-statements","version":"3.1.2","description":"Neater control statements (if/for) for jsx","author":{"name":"Alex Gilleran","email":"alex@alexgilleran.com"},"main":"src/index.js","repository":{"type":"git","url":"git+https://github.com/AlexGilleran/jsx-control-statements.git"},"bugs":{"url":"https://github.com/AlexGilleran/jsx-control-statements/issues"},"keywords":["react","jsx","if","else","for","each","loop","babel","react-component"],"license":"MIT","scripts":{"test":"mocha spec/*.js","cover":"istanbul cover -x \"**/spec/**\" node_modules/mocha/bin/_mocha spec/*.js"},"dependencies":{"babel-core":"^6.1.2","babel-plugin-syntax-jsx":"^6.1.18"},"devDependencies":{"babel-preset-react":"^6.1.2","chai":"^2.1.0","chai-spies":"^0.7.1","coveralls":"^2.11.6","istanbul":"^0.4.1","mocha":"^2.1.0","node-jsx":"^0.12.4","react":"^0.14.x","react-dom":"^0.14.x"},"readme":"# JSX Control Statements\n\n[![Build Status](https://travis-ci.org/AlexGilleran/jsx-control-statements.svg?branch=master)](https://travis-ci.org/AlexGilleran/jsx-control-statements) [![Coverage Status](https://coveralls.io/repos/AlexGilleran/jsx-control-statements/badge.svg?branch=master&service=github)](https://coveralls.io/github/AlexGilleran/jsx-control-statements?branch=master) [![npm version](https://img.shields.io/npm/v/jsx-control-statements.svg?style=flat)](https://www.npmjs.com/package/jsx-control-statements)\n\nIf you are used dedicated templating libraries like Handlebars it might come as surprise to you that JSX is missing\none important part which every other template language contains, i.e. control statements. This is by design since\nJSX by itself is not a templating library but just syntactic sugar. It only takes care of transforming XMLish\nexpressions into JavaScript expressions.\n\n*JSX-Control-Statements* extends JSX to allow for the essential control statements: **conditionals** and **loops**.\nIt does so by transforming component-like elements (e.g. `<If>` and `<For>`) to their JavaScript counterparts. Hence\nit is following the spirit of JSX by only adding syntactic sugar.\n\nThe only dependency *JSX-Control-Statements* relies upon is *Babel*.\n\n## A Note on Transformation and Alternative Solutions\nIt appears to be pretty easy to implement **conditionals as React component**, which is underlined by the amount\nof libraries which have taken this approach. However, all of them suffer from the same major caveat: A React component\nwill always evaluate all of its properties including the component body. Hence the following example will fail for\nthose libraries:\n```javascript\n<IfComponent condition={ item }>\n  { item.title }\n</IfComponent>\n```\nThe error will be \"Cannot read property 'title' of undefined\", because React will evaluate the body of the custom\ncomponent and pass it as \"children\" property to it. The only workaround is to force React into lazy evaluation by\nwrapping the statement in a function.\n\nThis is the reason why conditionals must be implemented in pure JS. *JSX-Control-Statements* only adds the\nsyntactic sugar to write conditionals as component, while it transforms this \"component\" to a pure JS expression.\n\nSee [Alternative Solutions](#alternative-solutions) for a more detailed comparison and pure JS solutions.\n\n## Installation\nAs a prerequisite you need to have [Babel](https://github.com/babel/babel) installed and configured in your project.\n\nInstall via npm:\n\n```\n  npm install --save-dev jsx-control-statements\n```\n\nThen you only need to specify *JSX-Control-Statements* as Babel plugin, which you would typically do in your `.babelrc`:\n```\n{\n  ...\n  \"plugins\": [\"jsx-control-statements\"]\n}\n```\nHowever, Babel can be used and configured in many different ways, so\n[use this guide](https://github.com/AlexGilleran/jsx-control-statements/wiki/Installation) to pick a configuration\nwhich fits your setup.\n\n### Linting\nSince all control statements are transformed via Babel, no `require` or `import` calls are needed. This in turn\n(well, and some more cases) would lead to warnings or errors by ESLint about undefined variables.\n\nBut fortunately you can use this\n[ESLint plugin for *JSX-Control-Statements*](https://github.com/vkbansal/eslint-plugin-jsx-control-statements)\nto lint your code.\n\n## Syntax\n### If Tag\n\nUsed to express the most simple conditional logic.\n\n```javascript\n// simple\n<If condition={ true }>\n  <span>IfBlock</span>\n</If>\n\n// using multiple child elements and / or expressions\n<If condition={ true }>\n  one\n  { \"two\" }\n  <span>three</span>\n  <span>four</span>\n</If>\n```\n#### &lt;If&gt;\nThe body of the if statement only gets evaluated if `condition` is true.\n\nProp Name | Prop Type | Required\n--------- | --------- | --------\ncondition | boolean | :white_check_mark:\n\n#### _&lt;Else /&gt; (deprecated)_\nThe else element has no properties and demarcates the `else` branch.\n\nThis element is deprecated, since it's bad JSX/XML semantics and breaks auto-formatting.\nPlease use `<Choose>` instead.\n\n#### Transformation\nIf statements transform to the *ternary operator*:\n```javascript\n// before transformation\n<If condition={ test }>\n  <span>Truth</span>\n</If>\n\n// after transformation\n{ test ? <span>Truth</span> : null }\n```\n\n### Choose Tag\n\nThis is an alternative syntax for more complex conditional statements. The syntax itself is XMLish and conforms by and\nlarge to JSTL or XSLT (the attribute is called `condition` instead of `test`):\n\n```javascript\n<Choose>\n  <When condition={ test1 }>\n    <span>IfBlock</span>\n  </When>\n  <When condition={ test2 }>\n    <span>ElseIfBlock</span>\n    <span>Another ElseIfBlock</span>\n    <span>...</span>\n  </When>\n  <Otherwise>\n    <span>ElseBlock</span>\n  </Otherwise>\n</Choose>\n\n// default block is optional; minimal example:\n<Choose>\n  <When condition={true}>\n    <span>IfBlock</span>\n  </When>\n</Choose>\n```\n\n#### &lt;Choose&gt;\nActs as a simple container and only allows for `<When>` and `<Otherwise>` as children.\nEach `<Choose>` statement requires at least one `<When>` block but may contain as many as desired.\nThe `<Otherwise>` block is optional.\n\n#### &lt;When&gt;\nAnalog to `<If>`.\n\nProp Name | Prop Type | Required\n--------- | --------- | --------\ncondition | boolean | :white_check_mark:\n\n#### &lt;Otherwise&gt;\n`<Otherwise>` has no attributes and demarcates the else branch of the conditional.\n\n#### Transformation\nThis syntax desugars into a (sequence of) ternary operator(s).\n\n```javascript\n// Before transformation\n<Choose>\n  <When condition={ test1 }>\n    <span>IfBlock1</span>\n  </When>\n  <When condition={ test2 }>\n    <span>IfBlock2</span>\n  </When>\n  <Otherwise>\n    <span>ElseBlock</span>\n  </Otherwise>\n</Choose>\n\n// After transformation\n{ test1 ? <span>IfBlock1</span> : test2 ? <span>IfBlock2</span> : <span>ElseBlock</span> }\n```\n\n### For Tag\n\nDefine `<For>` like so:\n```javascript\n  // you must provide the key attribute yourself\n  <For each=\"item\" of={ this.props.items }>\n    <span key={ item.id }>{ item.title }</span>\n  </For>\n\n  // using the index as key attribute is not stable if the array changes\n  <For each=\"item\" index=\"idx\" of={ [1,2,3] }>\n    <span key={ idx }>{ item }</span>\n    <span key={ idx + '_2' }>Static Text</span>\n  </For>\n```\n\nProp Name | Prop Type | Required | description\n--------- | --------- | -------- | -----------\nof | array or collection(Immutable) | :white_check_mark: | the array to iterate over. This can also be a collection (Immutable.js) or anything on which a function with the name `map` can be called\neach | string | | a reference to the current item of the array which can be used within the body as variable\nindex | string | | a reference to the index of the current item which can be used within the body as variable\n\nNote that a `<For>` *cannot* be at the root of a `render()` function in a React component, because then you'd\npotentially have multiple components without a parent to group them which isn't allowed. As with `<If>`, the same rules\nas using `Array.map()` apply - each element inside the loop should have a `key` attribute that uniquely identifies it.\n\n#### Transformation\nThere is no implementation for the map function within *jsx-control-statements*. We only expect that a\nfunction can be called on the passed object (to the `of` attribute) which has the same signature as `Array.map`.\n\n```javascript\n// before transformation\n<For each=\"item\" index=\"index\" of={ items )}>\n  <span key={ item.id }>{ index }. { item.title }</span>\n</For>\n\n// after transformation\n{\n  items.map( function(item, index) {\n    <span key={ item.id }>{ index }. { item.title }</span>\n  })\n}\n```\n\n## Alternative Solutions\n\n### Pure JavaScript\nSince everything will be compiled to JavaScript anyway, you might prefer to stick to pure JavaScript solutions.\n\n#### Conditionals\nProbably the most common way for simple conditionals is the use of the && operator:\n```javascript\n// simple if\n{ test && <span>true</span> }\n\n// additionally the else branch\n{ !test && <span>false</span> }\n```\n\nThe ternary operator is probably more elegant for if / else conditionals:\n```javascript\n// simple\n{ test ? <span>true</span> : <span>false</span> }\n\n// with multiple children\n{ test ? [<span key=\"1\">one</span>, <span key=\"2\">two</span>] : <span>false</span> }\n```\n\nAnother approach is to refactor your conditional into a function:\n```javascript\ntestFunc(condition){\n  if(condition) {\n    return <span>true</span>;\n  }\n  else {\n    return <span>false</span>\n  }\n}\n\nrender() {\n  return (\n    <div>{ testFunc(test) }</div>\n  )\n}\n```\n\n#### Loops\nNot many options here:\n```javascript\n{ items.map(function(item) {\n    <span key={ item.id }>{ item. title }</span>\n}) }\n```\n\n#### Comparison\nArguments pro *JSX-Control-Statements* in comparison to pure JS solutions:\n\n* More intuitive and easier to handle for designers and people with non-heavy JS background\n* JSX does not get fragmented by JS statements\n* Better readability and neatness, but that probably depends on you\n\nCons:\n\n* Penalty on build-time performance\n* Depends on Babel 6\n* Some Babel configuration\n\n### React Components\nThere are a reasonable amount of React components for conditionals (e.g. [react-if](https://github.com/romac/react-if), which inspired this in the first place), *JSX-Control-Statements* is the only approach we know of that avoids execution of all branches (see the [intro section](#a-note-on-transformation-and-alternative-solutions)), and there seems to be no other component-based solution to looping - while it would be possible to make a component that renders everything in `props.children` for every element of an array, you'd have to access the members of the array in that component instead of the one that uses it.\n\nFor more discussion on `If` in React by the react team, have a look at https://github.com/reactjs/react-future/issues/35.\n\nTo sum up:\n\n* Conditionals don't execute invalid paths\n* Loops with variable references to each element and index are made possible\n* No penalty on runtime performance\n* No import / require statements needed to use control statements\n* It works exactly as JSX is supposed to work: Plain syntactic sugar\n\nCons:\n\n* Depends on Babel 6\n* Some Babel configuration\n* Slightly longer build times\n* Requires an extra plugin to work with ESLint\n\n## Major Versions\n- 3.x.x is a pure Babel plugin supporting Babel >= 6.\n- 2.x.x was a Babel plugin supporting Babel >= 6, and a set of JSTransform visitors.\n- 1.x.x was a Babel plugin supporting Babel <= 5, and a set of JSTransform visitors.\n\nThis used to support both JSTransform and Babel, but as JSTransform is no longer maintained support was dropped. You can\nfind the code for the JSTransform version at https://github.com/AlexGilleran/jsx-control-statements-jstransform.\n\n## I Want to Contribute!\nYay! Please read the [Contributor's Guide](https://github.com/AlexGilleran/jsx-control-statements/blob/master/CONTRIBUTING.md).\n","readmeFilename":"README.md","homepage":"https://github.com/AlexGilleran/jsx-control-statements#readme","_id":"jsx-control-statements@3.1.2","_shasum":"38b7281264ec0b168dc2b634ae7d7e2e2d590c70","_resolved":"https://registry.npmjs.org/jsx-control-statements/-/jsx-control-statements-3.1.2.tgz","_from":"https://registry.npmjs.org/jsx-control-statements/-/jsx-control-statements-3.1.2.tgz"}