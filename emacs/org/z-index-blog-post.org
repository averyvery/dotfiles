Z-indexes and Sass maps: There has to be a (slightly) better way!

Z-indexes: They're a huge problem.

Okay, they're not a huge problem. Still, there comes a moment on every large project where I'm opening several files to figure out why the header is above the modal but under the breadcrumb but over the content area. It's a common problem that usually takes little to no effort to resolve, but just for fun, let's ask ourselves man's most important question:

http://3.bp.blogspot.com/-4IXj1PDuGxo/T-k_cjzndgI/AAAAAAAACcE/u_AShY1rCqc/s1600/CantSomeoneElseDoIt.png

The answer: yes! With a little Sass magic, you can automate the +1/-1 stacking of z-index items and keep your hands clean of all those gross numbers.

(note: this solution depends on Sass maps, which might not be available in your version of Sass http://viget.com/extend/sass-maps-are-awesome )

<h1>Basic example</h1>

http://codepen.io/averyvery/pen/jpyax

<h2>Start with a list</h2>

Begin with a simple list of the item names you want. These will be the keys you reference later, when you're building actual components:

$z-indexed-items: 'bottom' 'top'

<h2>Iterate and map</h2>

Now, step over your list and create a map that uses your items for keys, and your counter for the z-index:

$z-index-map: ()
$counter: 1

@each $item in $z-indexed-items
  $z-index-map: map-merge($z-index-map, ($item: $counter))
  $counter: $counter + 1

<h2>Mix in</h2>

z is a simple mixin that returns the z-index from the map you've created. Done!

=z($key)
  z-index: map-get($z-index-map, $key)

<h1>Alternate solutions</h1>

<h2>Nested maps</h2>

One global set of z-indexes is useful, but it's not going to totally replace z-index for you. Here's an example of the same idea (pre-building a map of z-indexes, then performing look-ups) in a two-tier map that uses groups.

http://codepen.io/averyvery/pen/Hmwhb

<h2>Using selectors instead</h2>

http://codepen.io/averyvery/pen/gIpjy

Iterating over selectors might be simpler if you're defining a basic global stack, but as the site grows it's probable going to come back to bite you. Tricky selectors, media queries, and dynamic class changes can trip up this approach.

<h2>List matching</h2>

http://codepen.io/averyvery/pen/xondH

The downside of all the above methods is that they requires you define your z-index stacks up-front - but in a large system, you might want to build your stacks as-needed alongside your components. In that case, you can use a mixin that iterates over a provided list, like in this example.

<h1>Problem, er, solved</h1>
